#C1
generate_random_permutation <- function(n) {
  U <- runif(n)
  
  permutation <- order(U)
  return(permutation)
}

generate_k_bit_words <- function(n, k) {
  words <- replicate(n, paste0(sample(c(0, 1), k, replace = TRUE), collapse = ""))
  
  words_decimal <- sapply(words, function(x) strtoi(x, base = 2))
  permutation <- order(words_decimal)
  sorted_words <- words[permutation]
  return(sorted_words)
}

strict_lexicographic_compare <- function(Wi, Wj) {
  Li <- nchar(Wi)
  Lj <- nchar(Wj)
  Lij <- min(Li, Lj)
  
  for (l in 1:Lij) {
    bit_i <- substr(Wi, l, l)
    bit_j <- substr(Wj, l, l)
    if (bit_i != bit_j) {
      return(bit_i < bit_j)
    }
  }
  
  if (Li != Lj) {
    while (nchar(Wi) == nchar(Wj)) {
      if (Li < Lj) {
        Wi <- paste0(Wi, sample(c(0, 1), 1))
      } else {
        Wj <- paste0(Wj, sample(c(0, 1), 1))
      }
      Li <- nchar(Wi)
      Lj <- nchar(Wj)
    }
    return(Li < Lj)
  } else {
    while (TRUE) {
      bit_i <- sample(c(0, 1), 1)
      bit_j <- sample(c(0, 1), 1)
      Wi <- paste0(Wi, bit_i)
      Wj <- paste0(Wj, bit_j)
      if (bit_i != bit_j) {
        return(bit_i < bit_j)
      }
    }
  }
}

strict_lexicographic_compare <- function(Wi, Wj) {
  Li <- nchar(Wi)
  Lj <- nchar(Wj)
  Lij <- min(Li, Lj)
  
  for (l in 1:Lij) {
    bit_i <- substr(Wi, l, l)
    bit_j <- substr(Wj, l, l)
    if (bit_i != bit_j) {
      return(bit_i < bit_j)
    }
  }
  
  if (Li != Lj) {
    # Append random bits to the shorter string until a difference is found
    while (nchar(Wi) == nchar(Wj)) {
      if (Li < Lj) {
        Wi <- paste0(Wi, sample(c(0, 1), 1))
      } else {
        Wj <- paste0(Wj, sample(c(0, 1), 1))
      }
      Li <- nchar(Wi)
      Lj <- nchar(Wj)
    }
    return(Li < Lj)
  } else {
    while (TRUE) {
      bit_i <- sample(c(0, 1), 1)
      bit_j <- sample(c(0, 1), 1)
      Wi <- paste0(Wi, bit_i)
      Wj <- paste0(Wj, bit_j)
      if (bit_i != bit_j) {
        return(bit_i < bit_j)
      }
    }
  }
}

randomized_quick_sort <- function(words, left, right) {
  if (left < right) {
    pivot_index <- sample(left:right, 1)
    words[c(left, pivot_index)] <- words[c(pivot_index, left)]
    pivot_new_index <- partition(words, left, right)
    words <- randomized_quick_sort(words, left, pivot_new_index - 1)
    words <- randomized_quick_sort(words, pivot_new_index + 1, right)
  }
  return(words)
}

partition <- function(words, left, right) {
  pivot <- words[left]
  i <- left + 1
  for (j in (left + 1):right) {
    if (strict_lexicographic_compare(words[j], pivot)) {
      words[c(i, j)] <- words[c(j, i)]
      i <- i + 1
    }
  }
  words[c(left, i - 1)] <- words[c(i - 1, left)]
  return(i - 1)
}

generate_and_sort_binary_strings <- function(n, k) {
  words <- replicate(n, paste0(sample(c(0, 1), k, replace = TRUE), collapse = ""))
  
  sorted_words <- randomized_quick_sort(words, 1, length(words))
  
  return(sorted_words)
}

#C2
monte_carlo_max_cut <- function(nodes, edges, iterations = 1000) {
  max_cut_size <- 0
  best_cut <- list()
  
  for (i in 1:iterations) {
    # Randomly partition the nodes into sets A and B
    A <- sample(nodes, length(nodes) / 2)
    B <- setdiff(nodes, A)
    
    # Calculate the cut size
    cut_size <- sum(sapply(edges, function(edge) {
      (edge[1] %in% A && edge[2] %in% B) || (edge[2] %in% A && edge[1] %in% B)
    }))
    
    # Update maximum cut size and best cut if needed
    if (cut_size > max_cut_size) {
      max_cut_size <- cut_size
      best_cut <- list(A = A, B = B)
    }
  }
  
  return(list(max_cut_size = max_cut_size, best_cut = best_cut))
}



